// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const acceptFriendRequest = `-- name: AcceptFriendRequest :exec
UPDATE friends
SET status = 'accepted'
WHERE sender_id = $1
    AND receiver_id = $2
`

type AcceptFriendRequestParams struct {
	SenderID   pgtype.UUID `json:"senderId"`
	ReceiverID pgtype.UUID `json:"receiverId"`
}

func (q *Queries) AcceptFriendRequest(ctx context.Context, arg AcceptFriendRequestParams) error {
	_, err := q.db.Exec(ctx, acceptFriendRequest, arg.SenderID, arg.ReceiverID)
	return err
}

const activateEmail = `-- name: ActivateEmail :one
UPDATE users
SET email_active = true,
    email_token = $1
WHERE email_token = $2
RETURNING email_active
`

type ActivateEmailParams struct {
	EmailToken   *string `json:"emailToken"`
	EmailToken_2 *string `json:"emailToken2"`
}

func (q *Queries) ActivateEmail(ctx context.Context, arg ActivateEmailParams) (bool, error) {
	row := q.db.QueryRow(ctx, activateEmail, arg.EmailToken, arg.EmailToken_2)
	var email_active bool
	err := row.Scan(&email_active)
	return email_active, err
}

const blockUser = `-- name: BlockUser :exec
INSERT INTO user_blocks (blocker_id, blocked_id)
VALUES ($1, $2) ON CONFLICT (blocker_id, blocked_id) DO NOTHING
`

type BlockUserParams struct {
	BlockerID pgtype.UUID `json:"blockerId"`
	BlockedID pgtype.UUID `json:"blockedId"`
}

func (q *Queries) BlockUser(ctx context.Context, arg BlockUserParams) error {
	_, err := q.db.Exec(ctx, blockUser, arg.BlockerID, arg.BlockedID)
	return err
}

const changeGroupName = `-- name: ChangeGroupName :exec
UPDATE chats
SET name = $1
WHERE id = $2
    AND chat_type = 'group'
`

type ChangeGroupNameParams struct {
	Name string      `json:"name"`
	ID   pgtype.UUID `json:"id"`
}

func (q *Queries) ChangeGroupName(ctx context.Context, arg ChangeGroupNameParams) error {
	_, err := q.db.Exec(ctx, changeGroupName, arg.Name, arg.ID)
	return err
}

const changeGroupPicture = `-- name: ChangeGroupPicture :exec
UPDATE chats
SET picture_url = $1
WHERE chat_type = 'group'
    AND id = $2
`

type ChangeGroupPictureParams struct {
	PictureUrl string      `json:"pictureUrl"`
	ID         pgtype.UUID `json:"id"`
}

func (q *Queries) ChangeGroupPicture(ctx context.Context, arg ChangeGroupPictureParams) error {
	_, err := q.db.Exec(ctx, changeGroupPicture, arg.PictureUrl, arg.ID)
	return err
}

const checkChatExists = `-- name: CheckChatExists :one
SELECT count(user_chat.chat_id) >= 2 AS chatcount
FROM user_chat
    JOIN chats c ON user_chat.chat_id = c.id
WHERE chat_type = 'one_on_one'
    AND (
        user_id = $1
        OR user_id = $2
    )
GROUP BY c.id
ORDER BY chatcount DESC
LIMIT 1
`

type CheckChatExistsParams struct {
	UserID   pgtype.UUID `json:"userId"`
	UserID_2 pgtype.UUID `json:"userId2"`
}

func (q *Queries) CheckChatExists(ctx context.Context, arg CheckChatExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkChatExists, arg.UserID, arg.UserID_2)
	var chatcount bool
	err := row.Scan(&chatcount)
	return chatcount, err
}

const checkDuplicateFriendRequest = `-- name: CheckDuplicateFriendRequest :one
SELECT EXISTS(
        SELECT 1
        FROM friends
        WHERE receiver_id = $1
            AND sender_id = (
                SELECT id
                FROM users
                WHERE email = $2
            )
    )
`

type CheckDuplicateFriendRequestParams struct {
	ReceiverID pgtype.UUID `json:"receiverId"`
	Email      string      `json:"email"`
}

func (q *Queries) CheckDuplicateFriendRequest(ctx context.Context, arg CheckDuplicateFriendRequestParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkDuplicateFriendRequest, arg.ReceiverID, arg.Email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createChatMessage = `-- name: CreateChatMessage :one
INSERT INTO chatmessages (
        chat_id,
        sender_id,
        text_content,
        message_type,
        media_url,
        delivery_status
    )
VALUES ($1, $2, $3, $4, $5, 'sent')
RETURNING id
`

type CreateChatMessageParams struct {
	ChatID      pgtype.UUID `json:"chatId"`
	SenderID    pgtype.UUID `json:"senderId"`
	TextContent *string     `json:"textContent"`
	MessageType MessageType `json:"messageType"`
	MediaUrl    *string     `json:"mediaUrl"`
}

func (q *Queries) CreateChatMessage(ctx context.Context, arg CreateChatMessageParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createChatMessage,
		arg.ChatID,
		arg.SenderID,
		arg.TextContent,
		arg.MessageType,
		arg.MediaUrl,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const createFriendRequest = `-- name: CreateFriendRequest :one
INSERT INTO friends (sender_id, receiver_id, status)
VALUES (
        $1,
        (
            SELECT id
            FROM users
            WHERE email = $2
        ),
        'pending'
    )
RETURNING status
`

type CreateFriendRequestParams struct {
	SenderID pgtype.UUID `json:"senderId"`
	Email    string      `json:"email"`
}

func (q *Queries) CreateFriendRequest(ctx context.Context, arg CreateFriendRequestParams) (FriendshipStatus, error) {
	row := q.db.QueryRow(ctx, createFriendRequest, arg.SenderID, arg.Email)
	var status FriendshipStatus
	err := row.Scan(&status)
	return status, err
}

const createGroupChat = `-- name: CreateGroupChat :one
INSERT INTO chats (
        name,
        picture_url,
        chat_type
    )
VALUES ($1, $2, 'group')
RETURNING id
`

type CreateGroupChatParams struct {
	Name       string `json:"name"`
	PictureUrl string `json:"pictureUrl"`
}

func (q *Queries) CreateGroupChat(ctx context.Context, arg CreateGroupChatParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createGroupChat, arg.Name, arg.PictureUrl)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const createOneOnOneChat = `-- name: CreateOneOnOneChat :one
INSERT INTO chats (
        name,
        picture_url,
        chat_type
    )
VALUES ('', '', 'one_on_one')
RETURNING id
`

func (q *Queries) CreateOneOnOneChat(ctx context.Context) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createOneOnOneChat)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
        email,
        username,
        password,
        salt,
        is_admin,
        email_active,
        email_token,
        picture_url
    )
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id,
    email,
    username,
    password,
    salt,
    is_admin,
    email_active,
    email_token,
    picture_url
`

type CreateUserParams struct {
	Email       string  `json:"email"`
	Username    string  `json:"username"`
	Password    string  `json:"password"`
	Salt        string  `json:"salt"`
	IsAdmin     bool    `json:"isAdmin"`
	EmailActive bool    `json:"emailActive"`
	EmailToken  *string `json:"emailToken"`
	PictureUrl  string  `json:"pictureUrl"`
}

type CreateUserRow struct {
	ID          pgtype.UUID `json:"id"`
	Email       string      `json:"email"`
	Username    string      `json:"username"`
	Password    string      `json:"password"`
	Salt        string      `json:"salt"`
	IsAdmin     bool        `json:"isAdmin"`
	EmailActive bool        `json:"emailActive"`
	EmailToken  *string     `json:"emailToken"`
	PictureUrl  string      `json:"pictureUrl"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.Username,
		arg.Password,
		arg.Salt,
		arg.IsAdmin,
		arg.EmailActive,
		arg.EmailToken,
		arg.PictureUrl,
	)
	var i CreateUserRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Salt,
		&i.IsAdmin,
		&i.EmailActive,
		&i.EmailToken,
		&i.PictureUrl,
	)
	return i, err
}

const declineFriendRequest = `-- name: DeclineFriendRequest :exec
DELETE FROM friends
WHERE sender_id = $1
    AND receiver_id = $2
`

type DeclineFriendRequestParams struct {
	SenderID   pgtype.UUID `json:"senderId"`
	ReceiverID pgtype.UUID `json:"receiverId"`
}

func (q *Queries) DeclineFriendRequest(ctx context.Context, arg DeclineFriendRequestParams) error {
	_, err := q.db.Exec(ctx, declineFriendRequest, arg.SenderID, arg.ReceiverID)
	return err
}

const deleteChangeEmail = `-- name: DeleteChangeEmail :exec
DELETE FROM change_email
WHERE confirmation_token = $1
`

func (q *Queries) DeleteChangeEmail(ctx context.Context, confirmationToken string) error {
	_, err := q.db.Exec(ctx, deleteChangeEmail, confirmationToken)
	return err
}

const deleteFromGroupChat = `-- name: DeleteFromGroupChat :exec
DELETE FROM user_chat
WHERE chat_id = $1
    AND user_id = ANY($2::UUID [])
`

type DeleteFromGroupChatParams struct {
	ChatID  pgtype.UUID   `json:"chatId"`
	Column2 []pgtype.UUID `json:"column2"`
}

func (q *Queries) DeleteFromGroupChat(ctx context.Context, arg DeleteFromGroupChatParams) error {
	_, err := q.db.Exec(ctx, deleteFromGroupChat, arg.ChatID, arg.Column2)
	return err
}

const emailExists = `-- name: EmailExists :one
SELECT count(1) > 0
FROM users
WHERE email = $1
`

func (q *Queries) EmailExists(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, emailExists, email)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const getAvailableGroupChats = `-- name: GetAvailableGroupChats :many
SELECT c.id,
    c.name AS chat_name,
    c.picture_url
FROM user_chat uc
    JOIN chats c ON c.id = uc.chat_id
WHERE uc.user_id = $1
    AND c.chat_type = 'group'
EXCEPT
SELECT c.id,
    c.name AS chat_name,
    c.picture_url
FROM user_chat uc
    JOIN chats c ON c.id = uc.chat_id
WHERE uc.user_id = $2
    AND c.chat_type = 'group'
`

type GetAvailableGroupChatsParams struct {
	UserID   pgtype.UUID `json:"userId"`
	UserID_2 pgtype.UUID `json:"userId2"`
}

type GetAvailableGroupChatsRow struct {
	ID         pgtype.UUID `json:"id"`
	ChatName   string      `json:"chatName"`
	PictureUrl string      `json:"pictureUrl"`
}

func (q *Queries) GetAvailableGroupChats(ctx context.Context, arg GetAvailableGroupChatsParams) ([]GetAvailableGroupChatsRow, error) {
	rows, err := q.db.Query(ctx, getAvailableGroupChats, arg.UserID, arg.UserID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAvailableGroupChatsRow
	for rows.Next() {
		var i GetAvailableGroupChatsRow
		if err := rows.Scan(&i.ID, &i.ChatName, &i.PictureUrl); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatMembers = `-- name: GetChatMembers :many
SELECT users.id,
    picture_url,
    username
FROM user_chat
    JOIN users ON users.id = user_chat.user_id
WHERE chat_id = $1
`

type GetChatMembersRow struct {
	ID         pgtype.UUID `json:"id"`
	PictureUrl string      `json:"pictureUrl"`
	Username   string      `json:"username"`
}

func (q *Queries) GetChatMembers(ctx context.Context, chatID pgtype.UUID) ([]GetChatMembersRow, error) {
	rows, err := q.db.Query(ctx, getChatMembers, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChatMembersRow
	for rows.Next() {
		var i GetChatMembersRow
		if err := rows.Scan(&i.ID, &i.PictureUrl, &i.Username); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatMessages = `-- name: GetChatMessages :many
SELECT chatmessages.id,
    sender_id,
    username AS sender_username,
    text_content,
    message_type,
    media_url,
    chatmessages.created_at,
    delivery_status
FROM chatmessages
    JOIN users u ON u.id = chatmessages.sender_id
WHERE chat_id = $1
ORDER BY chatmessages.created_at ASC
`

type GetChatMessagesRow struct {
	ID             pgtype.UUID      `json:"id"`
	SenderID       pgtype.UUID      `json:"senderId"`
	SenderUsername string           `json:"senderUsername"`
	TextContent    *string          `json:"textContent"`
	MessageType    MessageType      `json:"messageType"`
	MediaUrl       *string          `json:"mediaUrl"`
	CreatedAt      pgtype.Timestamp `json:"createdAt"`
	DeliveryStatus DeliveryStatus   `json:"deliveryStatus"`
}

func (q *Queries) GetChatMessages(ctx context.Context, chatID pgtype.UUID) ([]GetChatMessagesRow, error) {
	rows, err := q.db.Query(ctx, getChatMessages, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChatMessagesRow
	for rows.Next() {
		var i GetChatMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.SenderID,
			&i.SenderUsername,
			&i.TextContent,
			&i.MessageType,
			&i.MediaUrl,
			&i.CreatedAt,
			&i.DeliveryStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatType = `-- name: GetChatType :one
SELECT chat_type
FROM chats
WHERE id = $1
`

func (q *Queries) GetChatType(ctx context.Context, id pgtype.UUID) (ChatType, error) {
	row := q.db.QueryRow(ctx, getChatType, id)
	var chat_type ChatType
	err := row.Scan(&chat_type)
	return chat_type, err
}

const getChatsForUser = `-- name: GetChatsForUser :many
SELECT DISTINCT c.id,
    c.chat_type,
    c.created_at,
    CASE
        WHEN c.chat_type = 'one_on_one' THEN ou.username::TEXT
        ELSE c.name::TEXT
    END AS chat_name,
    CASE
        WHEN c.chat_type = 'one_on_one' THEN ou.picture_url::TEXT
        ELSE c.picture_url::TEXT
    END AS chat_picture_url,
    u.unread_messages,
    m.message_type,
    m.text_content,
    m.created_at as message_created_at,
    m.delivery_status,
    m.sender_id,
    su.username AS sender_username
FROM user_chat u
    JOIN chats c ON u.chat_id = c.id
    LEFT JOIN chatmessages m ON m.id = c.last_message_id -- Only join for one_on_one chats
    LEFT JOIN user_chat ouc ON c.id = ouc.chat_id
    AND ouc.user_id != $1
    AND c.chat_type = 'one_on_one'
    LEFT JOIN users ou ON ouc.user_id = ou.id
    LEFT JOIN users su ON m.sender_id = su.id
WHERE u.user_id = $1
`

type GetChatsForUserRow struct {
	ID               pgtype.UUID        `json:"id"`
	ChatType         ChatType           `json:"chatType"`
	CreatedAt        pgtype.Timestamp   `json:"createdAt"`
	ChatName         string             `json:"chatName"`
	ChatPictureUrl   string             `json:"chatPictureUrl"`
	UnreadMessages   int64              `json:"unreadMessages"`
	MessageType      NullMessageType    `json:"messageType"`
	TextContent      *string            `json:"textContent"`
	MessageCreatedAt pgtype.Timestamp   `json:"messageCreatedAt"`
	DeliveryStatus   NullDeliveryStatus `json:"deliveryStatus"`
	SenderID         pgtype.UUID        `json:"senderId"`
	SenderUsername   *string            `json:"senderUsername"`
}

func (q *Queries) GetChatsForUser(ctx context.Context, userID pgtype.UUID) ([]GetChatsForUserRow, error) {
	rows, err := q.db.Query(ctx, getChatsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChatsForUserRow
	for rows.Next() {
		var i GetChatsForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.ChatType,
			&i.CreatedAt,
			&i.ChatName,
			&i.ChatPictureUrl,
			&i.UnreadMessages,
			&i.MessageType,
			&i.TextContent,
			&i.MessageCreatedAt,
			&i.DeliveryStatus,
			&i.SenderID,
			&i.SenderUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmailActiveByToken = `-- name: GetEmailActiveByToken :one
SELECT email_active
FROM users
WHERE email_token = $1
`

func (q *Queries) GetEmailActiveByToken(ctx context.Context, emailToken *string) (bool, error) {
	row := q.db.QueryRow(ctx, getEmailActiveByToken, emailToken)
	var email_active bool
	err := row.Scan(&email_active)
	return email_active, err
}

const getGroupChatUserCount = `-- name: GetGroupChatUserCount :one
SELECT count(user_id)
FROM user_chat
WHERE chat_id = $1
GROUP BY chat_id
`

func (q *Queries) GetGroupChatUserCount(ctx context.Context, chatID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getGroupChatUserCount, chatID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getOneOnOneChatParticipant = `-- name: GetOneOnOneChatParticipant :one
SELECT user_id
FROM user_chat
WHERE chat_id = $1
    AND user_id != $2
`

type GetOneOnOneChatParticipantParams struct {
	ChatID pgtype.UUID `json:"chatId"`
	UserID pgtype.UUID `json:"userId"`
}

func (q *Queries) GetOneOnOneChatParticipant(ctx context.Context, arg GetOneOnOneChatParticipantParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getOneOnOneChatParticipant, arg.ChatID, arg.UserID)
	var user_id pgtype.UUID
	err := row.Scan(&user_id)
	return user_id, err
}

const getPendingFriendRequests = `-- name: GetPendingFriendRequests :many
SELECT sender_id,
    u.username AS sender_username,
    u.picture_url AS sender_profile_picture,
    u.email AS sender_email
FROM friends
    JOIN users u ON friends.sender_id = u.id
WHERE receiver_id = $1
    AND status = 'pending'
`

type GetPendingFriendRequestsRow struct {
	SenderID             pgtype.UUID `json:"senderId"`
	SenderUsername       string      `json:"senderUsername"`
	SenderProfilePicture string      `json:"senderProfilePicture"`
	SenderEmail          string      `json:"senderEmail"`
}

func (q *Queries) GetPendingFriendRequests(ctx context.Context, receiverID pgtype.UUID) ([]GetPendingFriendRequestsRow, error) {
	rows, err := q.db.Query(ctx, getPendingFriendRequests, receiverID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingFriendRequestsRow
	for rows.Next() {
		var i GetPendingFriendRequestsRow
		if err := rows.Scan(
			&i.SenderID,
			&i.SenderUsername,
			&i.SenderProfilePicture,
			&i.SenderEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id,
    email,
    username,
    password,
    salt,
    is_admin,
    email_active
FROM users
WHERE email = $1
`

type GetUserByEmailRow struct {
	ID          pgtype.UUID `json:"id"`
	Email       string      `json:"email"`
	Username    string      `json:"username"`
	Password    string      `json:"password"`
	Salt        string      `json:"salt"`
	IsAdmin     bool        `json:"isAdmin"`
	EmailActive bool        `json:"emailActive"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Salt,
		&i.IsAdmin,
		&i.EmailActive,
	)
	return i, err
}

const getUserByUUID = `-- name: GetUserByUUID :one
SELECT id,
    email,
    username,
    password,
    salt,
    is_admin,
    email_active,
    picture_url
FROM users
WHERE id = $1
`

type GetUserByUUIDRow struct {
	ID          pgtype.UUID `json:"id"`
	Email       string      `json:"email"`
	Username    string      `json:"username"`
	Password    string      `json:"password"`
	Salt        string      `json:"salt"`
	IsAdmin     bool        `json:"isAdmin"`
	EmailActive bool        `json:"emailActive"`
	PictureUrl  string      `json:"pictureUrl"`
}

func (q *Queries) GetUserByUUID(ctx context.Context, id pgtype.UUID) (GetUserByUUIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByUUID, id)
	var i GetUserByUUIDRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Salt,
		&i.IsAdmin,
		&i.EmailActive,
		&i.PictureUrl,
	)
	return i, err
}

const getUserContacts = `-- name: GetUserContacts :many
SELECT u.username,
    u.id,
    u.picture_url
FROM friends
    JOIN users u ON u.id = friends.sender_id
    OR friends.receiver_id = u.id
WHERE (
        receiver_id = $1
        OR sender_id = $1
    )
    AND status = 'accepted'
    AND u.id != $1
`

type GetUserContactsRow struct {
	Username   string      `json:"username"`
	ID         pgtype.UUID `json:"id"`
	PictureUrl string      `json:"pictureUrl"`
}

func (q *Queries) GetUserContacts(ctx context.Context, receiverID pgtype.UUID) ([]GetUserContactsRow, error) {
	rows, err := q.db.Query(ctx, getUserContacts, receiverID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserContactsRow
	for rows.Next() {
		var i GetUserContactsRow
		if err := rows.Scan(&i.Username, &i.ID, &i.PictureUrl); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementUnreadMessages = `-- name: IncrementUnreadMessages :one
UPDATE user_chat
SET unread_messages = (unread_messages + 1)
WHERE chat_id = $1
    AND user_id != $2
RETURNING true
`

type IncrementUnreadMessagesParams struct {
	ChatID pgtype.UUID `json:"chatId"`
	UserID pgtype.UUID `json:"userId"`
}

func (q *Queries) IncrementUnreadMessages(ctx context.Context, arg IncrementUnreadMessagesParams) (bool, error) {
	row := q.db.QueryRow(ctx, incrementUnreadMessages, arg.ChatID, arg.UserID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const insertParticipantChat = `-- name: InsertParticipantChat :one
INSERT INTO user_chat (user_id, chat_id, unread_messages)
VALUES ($1, $2, 0)
RETURNING chat_id
`

type InsertParticipantChatParams struct {
	UserID pgtype.UUID `json:"userId"`
	ChatID pgtype.UUID `json:"chatId"`
}

func (q *Queries) InsertParticipantChat(ctx context.Context, arg InsertParticipantChatParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, insertParticipantChat, arg.UserID, arg.ChatID)
	var chat_id pgtype.UUID
	err := row.Scan(&chat_id)
	return chat_id, err
}

const insertUserChat = `-- name: InsertUserChat :one
INSERT INTO user_chat (user_id, chat_id, unread_messages)
VALUES ($1, $2, 0)
RETURNING chat_id
`

type InsertUserChatParams struct {
	UserID pgtype.UUID `json:"userId"`
	ChatID pgtype.UUID `json:"chatId"`
}

func (q *Queries) InsertUserChat(ctx context.Context, arg InsertUserChatParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, insertUserChat, arg.UserID, arg.ChatID)
	var chat_id pgtype.UUID
	err := row.Scan(&chat_id)
	return chat_id, err
}

const isGroupChat = `-- name: IsGroupChat :one
SELECT chat_type = 'group'
FROM chats
WHERE id = $1
`

func (q *Queries) IsGroupChat(ctx context.Context, id pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, isGroupChat, id)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const leaveGroupChat = `-- name: LeaveGroupChat :exec
DELETE FROM user_chat
WHERE chat_id = $1
    AND user_id = $2
`

type LeaveGroupChatParams struct {
	ChatID pgtype.UUID `json:"chatId"`
	UserID pgtype.UUID `json:"userId"`
}

func (q *Queries) LeaveGroupChat(ctx context.Context, arg LeaveGroupChatParams) error {
	_, err := q.db.Exec(ctx, leaveGroupChat, arg.ChatID, arg.UserID)
	return err
}

const resetUnreadMessages = `-- name: ResetUnreadMessages :exec
UPDATE user_chat
SET unread_messages = 0
WHERE chat_id = $1
    AND user_id = $2
`

type ResetUnreadMessagesParams struct {
	ChatID pgtype.UUID `json:"chatId"`
	UserID pgtype.UUID `json:"userId"`
}

func (q *Queries) ResetUnreadMessages(ctx context.Context, arg ResetUnreadMessagesParams) error {
	_, err := q.db.Exec(ctx, resetUnreadMessages, arg.ChatID, arg.UserID)
	return err
}

const updateEmailFromChangeEmail = `-- name: UpdateEmailFromChangeEmail :one
UPDATE users u
SET email_active = true,
    email_token = $1,
    email = (
        SELECT c.new_email
        FROM change_email c
        WHERE c.confirmation_token = $2
    )
WHERE u.user_id = (
        SELECT c.user_id
        FROM change_email c
        WHERE c.confirmation_token = $2
    )
RETURNING u.email
`

type UpdateEmailFromChangeEmailParams struct {
	EmailToken        *string `json:"emailToken"`
	ConfirmationToken string  `json:"confirmationToken"`
}

func (q *Queries) UpdateEmailFromChangeEmail(ctx context.Context, arg UpdateEmailFromChangeEmailParams) (string, error) {
	row := q.db.QueryRow(ctx, updateEmailFromChangeEmail, arg.EmailToken, arg.ConfirmationToken)
	var email string
	err := row.Scan(&email)
	return email, err
}

const updateEmailToken = `-- name: UpdateEmailToken :one
UPDATE users
SET email_token = $1
WHERE email = $2
RETURNING email_token
`

type UpdateEmailTokenParams struct {
	EmailToken *string `json:"emailToken"`
	Email      string  `json:"email"`
}

func (q *Queries) UpdateEmailToken(ctx context.Context, arg UpdateEmailTokenParams) (*string, error) {
	row := q.db.QueryRow(ctx, updateEmailToken, arg.EmailToken, arg.Email)
	var email_token *string
	err := row.Scan(&email_token)
	return email_token, err
}

const updateLastMessageID = `-- name: UpdateLastMessageID :one
UPDATE chats
SET last_message_id = $1
WHERE id = $2
RETURNING id
`

type UpdateLastMessageIDParams struct {
	LastMessageID pgtype.UUID `json:"lastMessageId"`
	ID            pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateLastMessageID(ctx context.Context, arg UpdateLastMessageIDParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, updateLastMessageID, arg.LastMessageID, arg.ID)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const updatePictureURL = `-- name: UpdatePictureURL :exec
UPDATE users
SET picture_url = $1
WHERE id = $2
`

type UpdatePictureURLParams struct {
	PictureUrl string      `json:"pictureUrl"`
	ID         pgtype.UUID `json:"id"`
}

func (q *Queries) UpdatePictureURL(ctx context.Context, arg UpdatePictureURLParams) error {
	_, err := q.db.Exec(ctx, updatePictureURL, arg.PictureUrl, arg.ID)
	return err
}

const updateUsername = `-- name: UpdateUsername :one
UPDATE users
SET username = $1
WHERE id = $2
RETURNING username
`

type UpdateUsernameParams struct {
	Username string      `json:"username"`
	ID       pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateUsername(ctx context.Context, arg UpdateUsernameParams) (string, error) {
	row := q.db.QueryRow(ctx, updateUsername, arg.Username, arg.ID)
	var username string
	err := row.Scan(&username)
	return username, err
}

const upsertChangeEmail = `-- name: UpsertChangeEmail :one
INSERT INTO change_email (user_id, new_email, confirmation_token)
VALUES ($1, $2, $3) ON CONFLICT (user_id) DO
UPDATE
SET new_email = $2,
    confirmation_token = $3
RETURNING confirmation_token,
    new_email
`

type UpsertChangeEmailParams struct {
	UserID            pgtype.UUID `json:"userId"`
	NewEmail          string      `json:"newEmail"`
	ConfirmationToken string      `json:"confirmationToken"`
}

type UpsertChangeEmailRow struct {
	ConfirmationToken string `json:"confirmationToken"`
	NewEmail          string `json:"newEmail"`
}

func (q *Queries) UpsertChangeEmail(ctx context.Context, arg UpsertChangeEmailParams) (UpsertChangeEmailRow, error) {
	row := q.db.QueryRow(ctx, upsertChangeEmail, arg.UserID, arg.NewEmail, arg.ConfirmationToken)
	var i UpsertChangeEmailRow
	err := row.Scan(&i.ConfirmationToken, &i.NewEmail)
	return i, err
}

const validateChatID = `-- name: ValidateChatID :one
SELECT id
FROM chats
WHERE id = $1
`

func (q *Queries) ValidateChatID(ctx context.Context, id pgtype.UUID) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, validateChatID, id)
	err := row.Scan(&id)
	return id, err
}
