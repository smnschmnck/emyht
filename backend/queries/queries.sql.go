// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const activateEmail = `-- name: ActivateEmail :one
UPDATE users
SET email_active = true,
    email_token = $1
WHERE email_token = $2
RETURNING email_active
`

type ActivateEmailParams struct {
	EmailToken   pgtype.Text
	EmailToken_2 pgtype.Text
}

func (q *Queries) ActivateEmail(ctx context.Context, arg ActivateEmailParams) (bool, error) {
	row := q.db.QueryRow(ctx, activateEmail, arg.EmailToken, arg.EmailToken_2)
	var email_active bool
	err := row.Scan(&email_active)
	return email_active, err
}

const deleteChangeEmail = `-- name: DeleteChangeEmail :exec
DELETE FROM change_email
WHERE confirmation_token = $1
`

func (q *Queries) DeleteChangeEmail(ctx context.Context, confirmationToken string) error {
	_, err := q.db.Exec(ctx, deleteChangeEmail, confirmationToken)
	return err
}

const emailExists = `-- name: EmailExists :one
SELECT count(1) > 0
FROM users
WHERE email = $1
`

func (q *Queries) EmailExists(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, emailExists, email)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const getChatsForUser = `-- name: GetChatsForUser :many
SELECT c.chat_id,
    c.chat_type,
    c.creation_timestamp,
    CASE
        WHEN c.chat_type = 'one_on_one' THEN ou.username::TEXT
        ELSE c.name::TEXT
    END AS chat_name,
    CASE
        WHEN c.chat_type = 'one_on_one' THEN ou.picture_url::TEXT
        ELSE c.picture_url::TEXT
    END AS chat_picture_url,
    u.unread_messages,
    m.message_type,
    m.text_content,
    m.timestamp,
    m.delivery_status,
    m.sender_id,
    su.username AS sender_username
FROM user_chat u
    JOIN chats c ON u.chat_id = c.chat_id
    LEFT JOIN chatmessages m ON m.message_id = c.last_message_id
    LEFT JOIN user_chat ouc ON c.chat_id = ouc.chat_id
    AND ouc.uuid != $1 -- Other User in Chat
    LEFT JOIN users ou ON ouc.uuid = ou.uuid -- Other User Details
    LEFT JOIN users su ON m.sender_id = su.uuid -- Sender User Details
WHERE u.uuid = $1
`

type GetChatsForUserRow struct {
	ChatID            string
	ChatType          ChatType
	CreationTimestamp int64
	ChatName          string
	ChatPictureUrl    string
	UnreadMessages    int64
	MessageType       NullMessageType
	TextContent       pgtype.Text
	Timestamp         pgtype.Int8
	DeliveryStatus    NullDeliveryStatus
	SenderID          pgtype.Text
	SenderUsername    pgtype.Text
}

func (q *Queries) GetChatsForUser(ctx context.Context, uuid string) ([]GetChatsForUserRow, error) {
	rows, err := q.db.Query(ctx, getChatsForUser, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChatsForUserRow
	for rows.Next() {
		var i GetChatsForUserRow
		if err := rows.Scan(
			&i.ChatID,
			&i.ChatType,
			&i.CreationTimestamp,
			&i.ChatName,
			&i.ChatPictureUrl,
			&i.UnreadMessages,
			&i.MessageType,
			&i.TextContent,
			&i.Timestamp,
			&i.DeliveryStatus,
			&i.SenderID,
			&i.SenderUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmailActiveByToken = `-- name: GetEmailActiveByToken :one
SELECT email_active
FROM users
WHERE email_token = $1
`

func (q *Queries) GetEmailActiveByToken(ctx context.Context, emailToken pgtype.Text) (bool, error) {
	row := q.db.QueryRow(ctx, getEmailActiveByToken, emailToken)
	var email_active bool
	err := row.Scan(&email_active)
	return email_active, err
}

const updateEmailFromChangeEmail = `-- name: UpdateEmailFromChangeEmail :one
UPDATE users u
SET email_active = true,
    email_token = $1,
    email = (
        SELECT c.new_email
        FROM change_email c
        WHERE c.confirmation_token = $2
    )
WHERE u.uuid = (
        SELECT c.uuid
        FROM change_email c
        WHERE c.confirmation_token = $2
    )
RETURNING u.email
`

type UpdateEmailFromChangeEmailParams struct {
	EmailToken        pgtype.Text
	ConfirmationToken string
}

func (q *Queries) UpdateEmailFromChangeEmail(ctx context.Context, arg UpdateEmailFromChangeEmailParams) (string, error) {
	row := q.db.QueryRow(ctx, updateEmailFromChangeEmail, arg.EmailToken, arg.ConfirmationToken)
	var email string
	err := row.Scan(&email)
	return email, err
}

const updateUsername = `-- name: UpdateUsername :one
UPDATE users
SET username = $1
WHERE uuid = $2
RETURNING username
`

type UpdateUsernameParams struct {
	Username string
	Uuid     string
}

func (q *Queries) UpdateUsername(ctx context.Context, arg UpdateUsernameParams) (string, error) {
	row := q.db.QueryRow(ctx, updateUsername, arg.Username, arg.Uuid)
	var username string
	err := row.Scan(&username)
	return username, err
}

const upsertChangeEmail = `-- name: UpsertChangeEmail :one
INSERT INTO change_email (uuid, new_email, confirmation_token)
VALUES ($1, $2, $3) ON CONFLICT (uuid) DO
UPDATE
SET new_email = $2,
    confirmation_token = $3
RETURNING confirmation_token,
    new_email
`

type UpsertChangeEmailParams struct {
	Uuid              string
	NewEmail          string
	ConfirmationToken string
}

type UpsertChangeEmailRow struct {
	ConfirmationToken string
	NewEmail          string
}

func (q *Queries) UpsertChangeEmail(ctx context.Context, arg UpsertChangeEmailParams) (UpsertChangeEmailRow, error) {
	row := q.db.QueryRow(ctx, upsertChangeEmail, arg.Uuid, arg.NewEmail, arg.ConfirmationToken)
	var i UpsertChangeEmailRow
	err := row.Scan(&i.ConfirmationToken, &i.NewEmail)
	return i, err
}
