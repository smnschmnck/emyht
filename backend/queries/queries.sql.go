// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const acceptFriendRequest = `-- name: AcceptFriendRequest :exec
UPDATE friends
SET status = 'accepted'
WHERE sender = $1
    AND reciever = $2
`

type AcceptFriendRequestParams struct {
	Sender   string
	Reciever string
}

func (q *Queries) AcceptFriendRequest(ctx context.Context, arg AcceptFriendRequestParams) error {
	_, err := q.db.Exec(ctx, acceptFriendRequest, arg.Sender, arg.Reciever)
	return err
}

const activateEmail = `-- name: ActivateEmail :one
UPDATE users
SET email_active = true,
    email_token = $1
WHERE email_token = $2
RETURNING email_active
`

type ActivateEmailParams struct {
	EmailToken   pgtype.Text
	EmailToken_2 pgtype.Text
}

func (q *Queries) ActivateEmail(ctx context.Context, arg ActivateEmailParams) (bool, error) {
	row := q.db.QueryRow(ctx, activateEmail, arg.EmailToken, arg.EmailToken_2)
	var email_active bool
	err := row.Scan(&email_active)
	return email_active, err
}

const blockChat = `-- name: BlockChat :one
UPDATE chats
SET blocked = true
WHERE chat_id = $1
RETURNING blocked
`

func (q *Queries) BlockChat(ctx context.Context, chatID string) (pgtype.Bool, error) {
	row := q.db.QueryRow(ctx, blockChat, chatID)
	var blocked pgtype.Bool
	err := row.Scan(&blocked)
	return blocked, err
}

const blockFriendRequest = `-- name: BlockFriendRequest :exec
UPDATE friends
SET status = 'blocked'
WHERE sender = $1
    AND reciever = $2
`

type BlockFriendRequestParams struct {
	Sender   string
	Reciever string
}

func (q *Queries) BlockFriendRequest(ctx context.Context, arg BlockFriendRequestParams) error {
	_, err := q.db.Exec(ctx, blockFriendRequest, arg.Sender, arg.Reciever)
	return err
}

const blockUser = `-- name: BlockUser :exec
UPDATE friends
SET status = 'blocked'
WHERE (
        sender = $1
        AND reciever = $2
    )
    OR (
        sender = $2
        AND reciever = $1
    )
`

type BlockUserParams struct {
	Sender   string
	Reciever string
}

func (q *Queries) BlockUser(ctx context.Context, arg BlockUserParams) error {
	_, err := q.db.Exec(ctx, blockUser, arg.Sender, arg.Reciever)
	return err
}

const checkDuplicateFriendRequest = `-- name: CheckDuplicateFriendRequest :one
SELECT EXISTS(
        SELECT 1
        FROM friends
        WHERE reciever = $1
            AND sender = (
                SELECT uuid
                FROM users
                WHERE email = $2
            )
    )
`

type CheckDuplicateFriendRequestParams struct {
	Reciever string
	Email    string
}

func (q *Queries) CheckDuplicateFriendRequest(ctx context.Context, arg CheckDuplicateFriendRequestParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkDuplicateFriendRequest, arg.Reciever, arg.Email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createFriendRequest = `-- name: CreateFriendRequest :one
INSERT INTO friends (sender, reciever, status)
VALUES (
        $1,
        (
            SELECT uuid
            FROM users
            WHERE email = $2
        ),
        'pending'
    )
RETURNING status
`

type CreateFriendRequestParams struct {
	Sender string
	Email  string
}

func (q *Queries) CreateFriendRequest(ctx context.Context, arg CreateFriendRequestParams) (FriendshipStatus, error) {
	row := q.db.QueryRow(ctx, createFriendRequest, arg.Sender, arg.Email)
	var status FriendshipStatus
	err := row.Scan(&status)
	return status, err
}

const declineFriendRequest = `-- name: DeclineFriendRequest :exec
DELETE FROM friends
WHERE sender = $1
    AND reciever = $2
`

type DeclineFriendRequestParams struct {
	Sender   string
	Reciever string
}

func (q *Queries) DeclineFriendRequest(ctx context.Context, arg DeclineFriendRequestParams) error {
	_, err := q.db.Exec(ctx, declineFriendRequest, arg.Sender, arg.Reciever)
	return err
}

const deleteChangeEmail = `-- name: DeleteChangeEmail :exec
DELETE FROM change_email
WHERE confirmation_token = $1
`

func (q *Queries) DeleteChangeEmail(ctx context.Context, confirmationToken string) error {
	_, err := q.db.Exec(ctx, deleteChangeEmail, confirmationToken)
	return err
}

const emailExists = `-- name: EmailExists :one
SELECT count(1) > 0
FROM users
WHERE email = $1
`

func (q *Queries) EmailExists(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, emailExists, email)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const getChatsForUser = `-- name: GetChatsForUser :many
SELECT c.chat_id,
    c.chat_type,
    c.creation_timestamp,
    CASE
        WHEN c.chat_type = 'one_on_one' THEN ou.username::TEXT
        ELSE c.name::TEXT
    END AS chat_name,
    CASE
        WHEN c.chat_type = 'one_on_one' THEN ou.picture_url::TEXT
        ELSE c.picture_url::TEXT
    END AS chat_picture_url,
    u.unread_messages,
    m.message_type,
    m.text_content,
    m.timestamp,
    m.delivery_status,
    m.sender_id,
    su.username AS sender_username
FROM user_chat u
    JOIN chats c ON u.chat_id = c.chat_id
    LEFT JOIN chatmessages m ON m.message_id = c.last_message_id
    LEFT JOIN user_chat ouc ON c.chat_id = ouc.chat_id
    AND ouc.uuid != $1 -- Other User in Chat
    LEFT JOIN users ou ON ouc.uuid = ou.uuid -- Other User Details
    LEFT JOIN users su ON m.sender_id = su.uuid -- Sender User Details
WHERE u.uuid = $1
`

type GetChatsForUserRow struct {
	ChatID            string
	ChatType          ChatType
	CreationTimestamp int64
	ChatName          string
	ChatPictureUrl    string
	UnreadMessages    int64
	MessageType       NullMessageType
	TextContent       pgtype.Text
	Timestamp         pgtype.Int8
	DeliveryStatus    NullDeliveryStatus
	SenderID          pgtype.Text
	SenderUsername    pgtype.Text
}

func (q *Queries) GetChatsForUser(ctx context.Context, uuid string) ([]GetChatsForUserRow, error) {
	rows, err := q.db.Query(ctx, getChatsForUser, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChatsForUserRow
	for rows.Next() {
		var i GetChatsForUserRow
		if err := rows.Scan(
			&i.ChatID,
			&i.ChatType,
			&i.CreationTimestamp,
			&i.ChatName,
			&i.ChatPictureUrl,
			&i.UnreadMessages,
			&i.MessageType,
			&i.TextContent,
			&i.Timestamp,
			&i.DeliveryStatus,
			&i.SenderID,
			&i.SenderUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmailActiveByToken = `-- name: GetEmailActiveByToken :one
SELECT email_active
FROM users
WHERE email_token = $1
`

func (q *Queries) GetEmailActiveByToken(ctx context.Context, emailToken pgtype.Text) (bool, error) {
	row := q.db.QueryRow(ctx, getEmailActiveByToken, emailToken)
	var email_active bool
	err := row.Scan(&email_active)
	return email_active, err
}

const getPendingContactRequests = `-- name: GetPendingContactRequests :many
SELECT u.email AS email,
    TO_CHAR(created_at, 'DD.MM.YYYY') AS date
FROM friends
    JOIN users u ON u.uuid = friends.reciever
WHERE sender = $1
    AND status = 'pending'
`

type GetPendingContactRequestsRow struct {
	Email string
	Date  string
}

func (q *Queries) GetPendingContactRequests(ctx context.Context, sender string) ([]GetPendingContactRequestsRow, error) {
	rows, err := q.db.Query(ctx, getPendingContactRequests, sender)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingContactRequestsRow
	for rows.Next() {
		var i GetPendingContactRequestsRow
		if err := rows.Scan(&i.Email, &i.Date); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingFriendRequests = `-- name: GetPendingFriendRequests :many
SELECT sender AS sender_id,
    u.username AS sender_username,
    u.picture_url AS sender_profile_picture,
    u.email AS sender_email
FROM friends
    JOIN users u ON friends.sender = u.uuid
WHERE reciever = $1
    AND status = 'pending'
`

type GetPendingFriendRequestsRow struct {
	SenderID             string
	SenderUsername       string
	SenderProfilePicture string
	SenderEmail          string
}

func (q *Queries) GetPendingFriendRequests(ctx context.Context, reciever string) ([]GetPendingFriendRequestsRow, error) {
	rows, err := q.db.Query(ctx, getPendingFriendRequests, reciever)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingFriendRequestsRow
	for rows.Next() {
		var i GetPendingFriendRequestsRow
		if err := rows.Scan(
			&i.SenderID,
			&i.SenderUsername,
			&i.SenderProfilePicture,
			&i.SenderEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserContacts = `-- name: GetUserContacts :many
SELECT u.username,
    u.uuid,
    u.picture_url
FROM friends
    JOIN users u ON u.uuid = friends.sender
    OR friends.reciever = u.uuid
WHERE (
        reciever = $1
        OR sender = $1
    )
    AND status = 'accepted'
    AND u.uuid != $1
`

type GetUserContactsRow struct {
	Username   string
	Uuid       string
	PictureUrl string
}

func (q *Queries) GetUserContacts(ctx context.Context, reciever string) ([]GetUserContactsRow, error) {
	rows, err := q.db.Query(ctx, getUserContacts, reciever)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserContactsRow
	for rows.Next() {
		var i GetUserContactsRow
		if err := rows.Scan(&i.Username, &i.Uuid, &i.PictureUrl); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEmailFromChangeEmail = `-- name: UpdateEmailFromChangeEmail :one
UPDATE users u
SET email_active = true,
    email_token = $1,
    email = (
        SELECT c.new_email
        FROM change_email c
        WHERE c.confirmation_token = $2
    )
WHERE u.uuid = (
        SELECT c.uuid
        FROM change_email c
        WHERE c.confirmation_token = $2
    )
RETURNING u.email
`

type UpdateEmailFromChangeEmailParams struct {
	EmailToken        pgtype.Text
	ConfirmationToken string
}

func (q *Queries) UpdateEmailFromChangeEmail(ctx context.Context, arg UpdateEmailFromChangeEmailParams) (string, error) {
	row := q.db.QueryRow(ctx, updateEmailFromChangeEmail, arg.EmailToken, arg.ConfirmationToken)
	var email string
	err := row.Scan(&email)
	return email, err
}

const updateUsername = `-- name: UpdateUsername :one
UPDATE users
SET username = $1
WHERE uuid = $2
RETURNING username
`

type UpdateUsernameParams struct {
	Username string
	Uuid     string
}

func (q *Queries) UpdateUsername(ctx context.Context, arg UpdateUsernameParams) (string, error) {
	row := q.db.QueryRow(ctx, updateUsername, arg.Username, arg.Uuid)
	var username string
	err := row.Scan(&username)
	return username, err
}

const upsertChangeEmail = `-- name: UpsertChangeEmail :one
INSERT INTO change_email (uuid, new_email, confirmation_token)
VALUES ($1, $2, $3) ON CONFLICT (uuid) DO
UPDATE
SET new_email = $2,
    confirmation_token = $3
RETURNING confirmation_token,
    new_email
`

type UpsertChangeEmailParams struct {
	Uuid              string
	NewEmail          string
	ConfirmationToken string
}

type UpsertChangeEmailRow struct {
	ConfirmationToken string
	NewEmail          string
}

func (q *Queries) UpsertChangeEmail(ctx context.Context, arg UpsertChangeEmailParams) (UpsertChangeEmailRow, error) {
	row := q.db.QueryRow(ctx, upsertChangeEmail, arg.Uuid, arg.NewEmail, arg.ConfirmationToken)
	var i UpsertChangeEmailRow
	err := row.Scan(&i.ConfirmationToken, &i.NewEmail)
	return i, err
}
