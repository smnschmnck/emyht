// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const acceptFriendRequest = `-- name: AcceptFriendRequest :exec
UPDATE friends
SET status = 'accepted'
WHERE sender = $1
    AND reciever = $2
`

type AcceptFriendRequestParams struct {
	Sender   string `json:"sender"`
	Reciever string `json:"reciever"`
}

func (q *Queries) AcceptFriendRequest(ctx context.Context, arg AcceptFriendRequestParams) error {
	_, err := q.db.Exec(ctx, acceptFriendRequest, arg.Sender, arg.Reciever)
	return err
}

const activateEmail = `-- name: ActivateEmail :one
UPDATE users
SET email_active = true,
    email_token = $1
WHERE email_token = $2
RETURNING email_active
`

type ActivateEmailParams struct {
	EmailToken   pgtype.Text `json:"email_token"`
	EmailToken_2 pgtype.Text `json:"email_token_2"`
}

func (q *Queries) ActivateEmail(ctx context.Context, arg ActivateEmailParams) (bool, error) {
	row := q.db.QueryRow(ctx, activateEmail, arg.EmailToken, arg.EmailToken_2)
	var email_active bool
	err := row.Scan(&email_active)
	return email_active, err
}

const blockChat = `-- name: BlockChat :one
UPDATE chats
SET blocked = true
WHERE chat_id = $1
RETURNING blocked
`

func (q *Queries) BlockChat(ctx context.Context, chatID string) (pgtype.Bool, error) {
	row := q.db.QueryRow(ctx, blockChat, chatID)
	var blocked pgtype.Bool
	err := row.Scan(&blocked)
	return blocked, err
}

const blockFriendRequest = `-- name: BlockFriendRequest :exec
UPDATE friends
SET status = 'blocked'
WHERE sender = $1
    AND reciever = $2
`

type BlockFriendRequestParams struct {
	Sender   string `json:"sender"`
	Reciever string `json:"reciever"`
}

func (q *Queries) BlockFriendRequest(ctx context.Context, arg BlockFriendRequestParams) error {
	_, err := q.db.Exec(ctx, blockFriendRequest, arg.Sender, arg.Reciever)
	return err
}

const blockUser = `-- name: BlockUser :exec
UPDATE friends
SET status = 'blocked'
WHERE (
        sender = $1
        AND reciever = $2
    )
    OR (
        sender = $2
        AND reciever = $1
    )
`

type BlockUserParams struct {
	Sender   string `json:"sender"`
	Reciever string `json:"reciever"`
}

func (q *Queries) BlockUser(ctx context.Context, arg BlockUserParams) error {
	_, err := q.db.Exec(ctx, blockUser, arg.Sender, arg.Reciever)
	return err
}

const checkChatExists = `-- name: CheckChatExists :one
SELECT count(user_chat.chat_id) >= 2 AS chatcount
FROM user_chat
    JOIN chats c ON user_chat.chat_id = c.chat_id
WHERE chat_type = 'one_on_one'
    AND (
        uuid = $1
        OR uuid = $2
    )
GROUP BY c.chat_id
ORDER BY chatcount DESC
LIMIT 1
`

type CheckChatExistsParams struct {
	Uuid   string `json:"uuid"`
	Uuid_2 string `json:"uuid_2"`
}

func (q *Queries) CheckChatExists(ctx context.Context, arg CheckChatExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkChatExists, arg.Uuid, arg.Uuid_2)
	var chatcount bool
	err := row.Scan(&chatcount)
	return chatcount, err
}

const checkDuplicateFriendRequest = `-- name: CheckDuplicateFriendRequest :one
SELECT EXISTS(
        SELECT 1
        FROM friends
        WHERE reciever = $1
            AND sender = (
                SELECT uuid
                FROM users
                WHERE email = $2
            )
    )
`

type CheckDuplicateFriendRequestParams struct {
	Reciever string `json:"reciever"`
	Email    string `json:"email"`
}

func (q *Queries) CheckDuplicateFriendRequest(ctx context.Context, arg CheckDuplicateFriendRequestParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkDuplicateFriendRequest, arg.Reciever, arg.Email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createChatMessage = `-- name: CreateChatMessage :one
INSERT INTO chatmessages (
        message_id,
        chat_id,
        sender_id,
        text_content,
        message_type,
        media_url,
        timestamp,
        delivery_status
    )
VALUES ($1, $2, $3, $4, $5, $6, $7, 'sent')
RETURNING message_id
`

type CreateChatMessageParams struct {
	MessageID   string      `json:"message_id"`
	ChatID      string      `json:"chat_id"`
	SenderID    string      `json:"sender_id"`
	TextContent pgtype.Text `json:"text_content"`
	MessageType MessageType `json:"message_type"`
	MediaUrl    pgtype.Text `json:"media_url"`
	Timestamp   int64       `json:"timestamp"`
}

func (q *Queries) CreateChatMessage(ctx context.Context, arg CreateChatMessageParams) (string, error) {
	row := q.db.QueryRow(ctx, createChatMessage,
		arg.MessageID,
		arg.ChatID,
		arg.SenderID,
		arg.TextContent,
		arg.MessageType,
		arg.MediaUrl,
		arg.Timestamp,
	)
	var message_id string
	err := row.Scan(&message_id)
	return message_id, err
}

const createFriendRequest = `-- name: CreateFriendRequest :one
INSERT INTO friends (sender, reciever, status)
VALUES (
        $1,
        (
            SELECT uuid
            FROM users
            WHERE email = $2
        ),
        'pending'
    )
RETURNING status
`

type CreateFriendRequestParams struct {
	Sender string `json:"sender"`
	Email  string `json:"email"`
}

func (q *Queries) CreateFriendRequest(ctx context.Context, arg CreateFriendRequestParams) (FriendshipStatus, error) {
	row := q.db.QueryRow(ctx, createFriendRequest, arg.Sender, arg.Email)
	var status FriendshipStatus
	err := row.Scan(&status)
	return status, err
}

const createGroupChat = `-- name: CreateGroupChat :one
INSERT INTO chats (
        chat_id,
        name,
        picture_url,
        chat_type,
        creation_timestamp
    )
VALUES ($1, $2, $3, 'group', $4)
RETURNING chat_id
`

type CreateGroupChatParams struct {
	ChatID            string `json:"chat_id"`
	Name              string `json:"name"`
	PictureUrl        string `json:"picture_url"`
	CreationTimestamp int64  `json:"creation_timestamp"`
}

func (q *Queries) CreateGroupChat(ctx context.Context, arg CreateGroupChatParams) (string, error) {
	row := q.db.QueryRow(ctx, createGroupChat,
		arg.ChatID,
		arg.Name,
		arg.PictureUrl,
		arg.CreationTimestamp,
	)
	var chat_id string
	err := row.Scan(&chat_id)
	return chat_id, err
}

const createOneOnOneChat = `-- name: CreateOneOnOneChat :one
INSERT INTO chats (
        chat_id,
        name,
        picture_url,
        chat_type,
        creation_timestamp
    )
VALUES ($1, '', '', 'one_on_one', $2)
RETURNING chat_id
`

type CreateOneOnOneChatParams struct {
	ChatID            string `json:"chat_id"`
	CreationTimestamp int64  `json:"creation_timestamp"`
}

func (q *Queries) CreateOneOnOneChat(ctx context.Context, arg CreateOneOnOneChatParams) (string, error) {
	row := q.db.QueryRow(ctx, createOneOnOneChat, arg.ChatID, arg.CreationTimestamp)
	var chat_id string
	err := row.Scan(&chat_id)
	return chat_id, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
        uuid,
        email,
        username,
        password,
        salt,
        is_admin,
        email_active,
        email_token,
        picture_url
    )
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING uuid,
    email,
    username,
    password,
    salt,
    is_admin,
    email_active,
    email_token,
    picture_url
`

type CreateUserParams struct {
	Uuid        string      `json:"uuid"`
	Email       string      `json:"email"`
	Username    string      `json:"username"`
	Password    string      `json:"password"`
	Salt        string      `json:"salt"`
	IsAdmin     bool        `json:"is_admin"`
	EmailActive bool        `json:"email_active"`
	EmailToken  pgtype.Text `json:"email_token"`
	PictureUrl  string      `json:"picture_url"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Uuid,
		arg.Email,
		arg.Username,
		arg.Password,
		arg.Salt,
		arg.IsAdmin,
		arg.EmailActive,
		arg.EmailToken,
		arg.PictureUrl,
	)
	var i User
	err := row.Scan(
		&i.Uuid,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Salt,
		&i.IsAdmin,
		&i.EmailActive,
		&i.EmailToken,
		&i.PictureUrl,
	)
	return i, err
}

const declineFriendRequest = `-- name: DeclineFriendRequest :exec
DELETE FROM friends
WHERE sender = $1
    AND reciever = $2
`

type DeclineFriendRequestParams struct {
	Sender   string `json:"sender"`
	Reciever string `json:"reciever"`
}

func (q *Queries) DeclineFriendRequest(ctx context.Context, arg DeclineFriendRequestParams) error {
	_, err := q.db.Exec(ctx, declineFriendRequest, arg.Sender, arg.Reciever)
	return err
}

const deleteChangeEmail = `-- name: DeleteChangeEmail :exec
DELETE FROM change_email
WHERE confirmation_token = $1
`

func (q *Queries) DeleteChangeEmail(ctx context.Context, confirmationToken string) error {
	_, err := q.db.Exec(ctx, deleteChangeEmail, confirmationToken)
	return err
}

const emailExists = `-- name: EmailExists :one
SELECT count(1) > 0
FROM users
WHERE email = $1
`

func (q *Queries) EmailExists(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, emailExists, email)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const getAvailableGroupChats = `-- name: GetAvailableGroupChats :many
SELECT c.chat_id,
    c.name AS chat_name,
    c.picture_url
FROM user_chat uc
    JOIN chats c ON c.chat_id = uc.chat_id
WHERE uc.uuid = $1
    AND c.chat_type = 'group'
EXCEPT
SELECT c.chat_id,
    c.name AS chat_name,
    c.picture_url
FROM user_chat uc
    JOIN chats c ON c.chat_id = uc.chat_id
WHERE uc.uuid = $2
    AND c.chat_type = 'group'
`

type GetAvailableGroupChatsParams struct {
	Uuid   string `json:"uuid"`
	Uuid_2 string `json:"uuid_2"`
}

type GetAvailableGroupChatsRow struct {
	ChatID     string `json:"chat_id"`
	ChatName   string `json:"chat_name"`
	PictureUrl string `json:"picture_url"`
}

func (q *Queries) GetAvailableGroupChats(ctx context.Context, arg GetAvailableGroupChatsParams) ([]GetAvailableGroupChatsRow, error) {
	rows, err := q.db.Query(ctx, getAvailableGroupChats, arg.Uuid, arg.Uuid_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAvailableGroupChatsRow
	for rows.Next() {
		var i GetAvailableGroupChatsRow
		if err := rows.Scan(&i.ChatID, &i.ChatName, &i.PictureUrl); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatMembers = `-- name: GetChatMembers :many
SELECT uuid
FROM user_chat
WHERE chat_id = $1
`

func (q *Queries) GetChatMembers(ctx context.Context, chatID string) ([]string, error) {
	rows, err := q.db.Query(ctx, getChatMembers, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var uuid string
		if err := rows.Scan(&uuid); err != nil {
			return nil, err
		}
		items = append(items, uuid)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatMessages = `-- name: GetChatMessages :many
SELECT message_id,
    sender_id,
    username AS sender_username,
    text_content,
    message_type,
    media_url,
    timestamp,
    delivery_status
FROM chatmessages
    JOIN users u ON u.uuid = chatmessages.sender_id
WHERE chat_id = $1
ORDER BY timestamp ASC
`

type GetChatMessagesRow struct {
	MessageID      string         `json:"message_id"`
	SenderID       string         `json:"sender_id"`
	SenderUsername string         `json:"sender_username"`
	TextContent    pgtype.Text    `json:"text_content"`
	MessageType    MessageType    `json:"message_type"`
	MediaUrl       pgtype.Text    `json:"media_url"`
	Timestamp      int64          `json:"timestamp"`
	DeliveryStatus DeliveryStatus `json:"delivery_status"`
}

func (q *Queries) GetChatMessages(ctx context.Context, chatID string) ([]GetChatMessagesRow, error) {
	rows, err := q.db.Query(ctx, getChatMessages, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChatMessagesRow
	for rows.Next() {
		var i GetChatMessagesRow
		if err := rows.Scan(
			&i.MessageID,
			&i.SenderID,
			&i.SenderUsername,
			&i.TextContent,
			&i.MessageType,
			&i.MediaUrl,
			&i.Timestamp,
			&i.DeliveryStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatType = `-- name: GetChatType :one
SELECT chat_type
FROM chats
WHERE chat_id = $1
`

func (q *Queries) GetChatType(ctx context.Context, chatID string) (ChatType, error) {
	row := q.db.QueryRow(ctx, getChatType, chatID)
	var chat_type ChatType
	err := row.Scan(&chat_type)
	return chat_type, err
}

const getChatsForUser = `-- name: GetChatsForUser :many
SELECT c.chat_id,
    c.chat_type,
    c.creation_timestamp,
    CASE
        WHEN c.chat_type = 'one_on_one' THEN ou.username::TEXT
        ELSE c.name::TEXT
    END AS chat_name,
    CASE
        WHEN c.chat_type = 'one_on_one' THEN ou.picture_url::TEXT
        ELSE c.picture_url::TEXT
    END AS chat_picture_url,
    u.unread_messages,
    m.message_type,
    m.text_content,
    m.timestamp,
    m.delivery_status,
    m.sender_id,
    su.username AS sender_username
FROM user_chat u
    JOIN chats c ON u.chat_id = c.chat_id
    LEFT JOIN chatmessages m ON m.message_id = c.last_message_id
    LEFT JOIN user_chat ouc ON c.chat_id = ouc.chat_id
    AND ouc.uuid != $1 -- Other User in Chat
    LEFT JOIN users ou ON ouc.uuid = ou.uuid -- Other User Details
    LEFT JOIN users su ON m.sender_id = su.uuid -- Sender User Details
WHERE u.uuid = $1
`

type GetChatsForUserRow struct {
	ChatID            string             `json:"chat_id"`
	ChatType          ChatType           `json:"chat_type"`
	CreationTimestamp int64              `json:"creation_timestamp"`
	ChatName          string             `json:"chat_name"`
	ChatPictureUrl    string             `json:"chat_picture_url"`
	UnreadMessages    int64              `json:"unread_messages"`
	MessageType       NullMessageType    `json:"message_type"`
	TextContent       pgtype.Text        `json:"text_content"`
	Timestamp         pgtype.Int8        `json:"timestamp"`
	DeliveryStatus    NullDeliveryStatus `json:"delivery_status"`
	SenderID          pgtype.Text        `json:"sender_id"`
	SenderUsername    pgtype.Text        `json:"sender_username"`
}

func (q *Queries) GetChatsForUser(ctx context.Context, uuid string) ([]GetChatsForUserRow, error) {
	rows, err := q.db.Query(ctx, getChatsForUser, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChatsForUserRow
	for rows.Next() {
		var i GetChatsForUserRow
		if err := rows.Scan(
			&i.ChatID,
			&i.ChatType,
			&i.CreationTimestamp,
			&i.ChatName,
			&i.ChatPictureUrl,
			&i.UnreadMessages,
			&i.MessageType,
			&i.TextContent,
			&i.Timestamp,
			&i.DeliveryStatus,
			&i.SenderID,
			&i.SenderUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmailActiveByToken = `-- name: GetEmailActiveByToken :one
SELECT email_active
FROM users
WHERE email_token = $1
`

func (q *Queries) GetEmailActiveByToken(ctx context.Context, emailToken pgtype.Text) (bool, error) {
	row := q.db.QueryRow(ctx, getEmailActiveByToken, emailToken)
	var email_active bool
	err := row.Scan(&email_active)
	return email_active, err
}

const getGroupChatUserCount = `-- name: GetGroupChatUserCount :one
SELECT count(uuid)
FROM user_chat
WHERE chat_id = $1
GROUP BY chat_id
`

func (q *Queries) GetGroupChatUserCount(ctx context.Context, chatID string) (int64, error) {
	row := q.db.QueryRow(ctx, getGroupChatUserCount, chatID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getOneOnOneChatParticipant = `-- name: GetOneOnOneChatParticipant :one
SELECT uuid
FROM user_chat
WHERE chat_id = $1
    AND uuid != $2
`

type GetOneOnOneChatParticipantParams struct {
	ChatID string `json:"chat_id"`
	Uuid   string `json:"uuid"`
}

func (q *Queries) GetOneOnOneChatParticipant(ctx context.Context, arg GetOneOnOneChatParticipantParams) (string, error) {
	row := q.db.QueryRow(ctx, getOneOnOneChatParticipant, arg.ChatID, arg.Uuid)
	var uuid string
	err := row.Scan(&uuid)
	return uuid, err
}

const getPendingContactRequests = `-- name: GetPendingContactRequests :many
SELECT u.email AS email,
    TO_CHAR(created_at, 'DD.MM.YYYY') AS date
FROM friends
    JOIN users u ON u.uuid = friends.reciever
WHERE sender = $1
    AND status = 'pending'
`

type GetPendingContactRequestsRow struct {
	Email string `json:"email"`
	Date  string `json:"date"`
}

func (q *Queries) GetPendingContactRequests(ctx context.Context, sender string) ([]GetPendingContactRequestsRow, error) {
	rows, err := q.db.Query(ctx, getPendingContactRequests, sender)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingContactRequestsRow
	for rows.Next() {
		var i GetPendingContactRequestsRow
		if err := rows.Scan(&i.Email, &i.Date); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingFriendRequests = `-- name: GetPendingFriendRequests :many
SELECT sender AS sender_id,
    u.username AS sender_username,
    u.picture_url AS sender_profile_picture,
    u.email AS sender_email
FROM friends
    JOIN users u ON friends.sender = u.uuid
WHERE reciever = $1
    AND status = 'pending'
`

type GetPendingFriendRequestsRow struct {
	SenderID             string `json:"sender_id"`
	SenderUsername       string `json:"sender_username"`
	SenderProfilePicture string `json:"sender_profile_picture"`
	SenderEmail          string `json:"sender_email"`
}

func (q *Queries) GetPendingFriendRequests(ctx context.Context, reciever string) ([]GetPendingFriendRequestsRow, error) {
	rows, err := q.db.Query(ctx, getPendingFriendRequests, reciever)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingFriendRequestsRow
	for rows.Next() {
		var i GetPendingFriendRequestsRow
		if err := rows.Scan(
			&i.SenderID,
			&i.SenderUsername,
			&i.SenderProfilePicture,
			&i.SenderEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT uuid,
    email,
    username,
    password,
    salt,
    is_admin,
    email_active
FROM users
WHERE email = $1
`

type GetUserByEmailRow struct {
	Uuid        string `json:"uuid"`
	Email       string `json:"email"`
	Username    string `json:"username"`
	Password    string `json:"password"`
	Salt        string `json:"salt"`
	IsAdmin     bool   `json:"is_admin"`
	EmailActive bool   `json:"email_active"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.Uuid,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Salt,
		&i.IsAdmin,
		&i.EmailActive,
	)
	return i, err
}

const getUserByUUID = `-- name: GetUserByUUID :one
SELECT uuid,
    email,
    username,
    password,
    salt,
    is_admin,
    email_active,
    picture_url
FROM users
WHERE uuid = $1
`

type GetUserByUUIDRow struct {
	Uuid        string `json:"uuid"`
	Email       string `json:"email"`
	Username    string `json:"username"`
	Password    string `json:"password"`
	Salt        string `json:"salt"`
	IsAdmin     bool   `json:"is_admin"`
	EmailActive bool   `json:"email_active"`
	PictureUrl  string `json:"picture_url"`
}

func (q *Queries) GetUserByUUID(ctx context.Context, uuid string) (GetUserByUUIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByUUID, uuid)
	var i GetUserByUUIDRow
	err := row.Scan(
		&i.Uuid,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Salt,
		&i.IsAdmin,
		&i.EmailActive,
		&i.PictureUrl,
	)
	return i, err
}

const getUserContacts = `-- name: GetUserContacts :many
SELECT u.username,
    u.uuid,
    u.picture_url
FROM friends
    JOIN users u ON u.uuid = friends.sender
    OR friends.reciever = u.uuid
WHERE (
        reciever = $1
        OR sender = $1
    )
    AND status = 'accepted'
    AND u.uuid != $1
`

type GetUserContactsRow struct {
	Username   string `json:"username"`
	Uuid       string `json:"uuid"`
	PictureUrl string `json:"picture_url"`
}

func (q *Queries) GetUserContacts(ctx context.Context, reciever string) ([]GetUserContactsRow, error) {
	rows, err := q.db.Query(ctx, getUserContacts, reciever)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserContactsRow
	for rows.Next() {
		var i GetUserContactsRow
		if err := rows.Scan(&i.Username, &i.Uuid, &i.PictureUrl); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementUnreadMessages = `-- name: IncrementUnreadMessages :one
UPDATE user_chat
SET unread_messages = (unread_messages + 1)
WHERE chat_id = $1
    AND uuid != $2
RETURNING true
`

type IncrementUnreadMessagesParams struct {
	ChatID string `json:"chat_id"`
	Uuid   string `json:"uuid"`
}

func (q *Queries) IncrementUnreadMessages(ctx context.Context, arg IncrementUnreadMessagesParams) (bool, error) {
	row := q.db.QueryRow(ctx, incrementUnreadMessages, arg.ChatID, arg.Uuid)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const insertParticipantChat = `-- name: InsertParticipantChat :one
INSERT INTO user_chat (uuid, chat_id, unread_messages)
VALUES ($1, $2, 0)
RETURNING chat_id
`

type InsertParticipantChatParams struct {
	Uuid   string `json:"uuid"`
	ChatID string `json:"chat_id"`
}

func (q *Queries) InsertParticipantChat(ctx context.Context, arg InsertParticipantChatParams) (string, error) {
	row := q.db.QueryRow(ctx, insertParticipantChat, arg.Uuid, arg.ChatID)
	var chat_id string
	err := row.Scan(&chat_id)
	return chat_id, err
}

const insertUserChat = `-- name: InsertUserChat :one
INSERT INTO user_chat (uuid, chat_id, unread_messages)
VALUES ($1, $2, 0)
RETURNING chat_id
`

type InsertUserChatParams struct {
	Uuid   string `json:"uuid"`
	ChatID string `json:"chat_id"`
}

func (q *Queries) InsertUserChat(ctx context.Context, arg InsertUserChatParams) (string, error) {
	row := q.db.QueryRow(ctx, insertUserChat, arg.Uuid, arg.ChatID)
	var chat_id string
	err := row.Scan(&chat_id)
	return chat_id, err
}

const isGroupChat = `-- name: IsGroupChat :one
SELECT chat_type = 'group'
FROM chats
WHERE chat_id = $1
`

func (q *Queries) IsGroupChat(ctx context.Context, chatID string) (bool, error) {
	row := q.db.QueryRow(ctx, isGroupChat, chatID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const leaveGroupChat = `-- name: LeaveGroupChat :exec
DELETE FROM user_chat
WHERE chat_id = $1
    AND uuid = $2
`

type LeaveGroupChatParams struct {
	ChatID string `json:"chat_id"`
	Uuid   string `json:"uuid"`
}

func (q *Queries) LeaveGroupChat(ctx context.Context, arg LeaveGroupChatParams) error {
	_, err := q.db.Exec(ctx, leaveGroupChat, arg.ChatID, arg.Uuid)
	return err
}

const resetUnreadMessages = `-- name: ResetUnreadMessages :exec
UPDATE user_chat
SET unread_messages = 0
WHERE chat_id = $1
    AND uuid = $2
`

type ResetUnreadMessagesParams struct {
	ChatID string `json:"chat_id"`
	Uuid   string `json:"uuid"`
}

func (q *Queries) ResetUnreadMessages(ctx context.Context, arg ResetUnreadMessagesParams) error {
	_, err := q.db.Exec(ctx, resetUnreadMessages, arg.ChatID, arg.Uuid)
	return err
}

const updateEmailFromChangeEmail = `-- name: UpdateEmailFromChangeEmail :one
UPDATE users u
SET email_active = true,
    email_token = $1,
    email = (
        SELECT c.new_email
        FROM change_email c
        WHERE c.confirmation_token = $2
    )
WHERE u.uuid = (
        SELECT c.uuid
        FROM change_email c
        WHERE c.confirmation_token = $2
    )
RETURNING u.email
`

type UpdateEmailFromChangeEmailParams struct {
	EmailToken        pgtype.Text `json:"email_token"`
	ConfirmationToken string      `json:"confirmation_token"`
}

func (q *Queries) UpdateEmailFromChangeEmail(ctx context.Context, arg UpdateEmailFromChangeEmailParams) (string, error) {
	row := q.db.QueryRow(ctx, updateEmailFromChangeEmail, arg.EmailToken, arg.ConfirmationToken)
	var email string
	err := row.Scan(&email)
	return email, err
}

const updateEmailToken = `-- name: UpdateEmailToken :one
UPDATE users
SET email_token = $1
WHERE email = $2
RETURNING email_token
`

type UpdateEmailTokenParams struct {
	EmailToken pgtype.Text `json:"email_token"`
	Email      string      `json:"email"`
}

func (q *Queries) UpdateEmailToken(ctx context.Context, arg UpdateEmailTokenParams) (pgtype.Text, error) {
	row := q.db.QueryRow(ctx, updateEmailToken, arg.EmailToken, arg.Email)
	var email_token pgtype.Text
	err := row.Scan(&email_token)
	return email_token, err
}

const updateLastMessageID = `-- name: UpdateLastMessageID :one
UPDATE chats
SET last_message_id = $1
WHERE chat_id = $2
RETURNING chat_id
`

type UpdateLastMessageIDParams struct {
	LastMessageID pgtype.Text `json:"last_message_id"`
	ChatID        string      `json:"chat_id"`
}

func (q *Queries) UpdateLastMessageID(ctx context.Context, arg UpdateLastMessageIDParams) (string, error) {
	row := q.db.QueryRow(ctx, updateLastMessageID, arg.LastMessageID, arg.ChatID)
	var chat_id string
	err := row.Scan(&chat_id)
	return chat_id, err
}

const updatePictureURL = `-- name: UpdatePictureURL :exec
UPDATE users
SET picture_url = $1
WHERE uuid = $2
`

type UpdatePictureURLParams struct {
	PictureUrl string `json:"picture_url"`
	Uuid       string `json:"uuid"`
}

func (q *Queries) UpdatePictureURL(ctx context.Context, arg UpdatePictureURLParams) error {
	_, err := q.db.Exec(ctx, updatePictureURL, arg.PictureUrl, arg.Uuid)
	return err
}

const updateUsername = `-- name: UpdateUsername :one
UPDATE users
SET username = $1
WHERE uuid = $2
RETURNING username
`

type UpdateUsernameParams struct {
	Username string `json:"username"`
	Uuid     string `json:"uuid"`
}

func (q *Queries) UpdateUsername(ctx context.Context, arg UpdateUsernameParams) (string, error) {
	row := q.db.QueryRow(ctx, updateUsername, arg.Username, arg.Uuid)
	var username string
	err := row.Scan(&username)
	return username, err
}

const upsertChangeEmail = `-- name: UpsertChangeEmail :one
INSERT INTO change_email (uuid, new_email, confirmation_token)
VALUES ($1, $2, $3) ON CONFLICT (uuid) DO
UPDATE
SET new_email = $2,
    confirmation_token = $3
RETURNING confirmation_token,
    new_email
`

type UpsertChangeEmailParams struct {
	Uuid              string `json:"uuid"`
	NewEmail          string `json:"new_email"`
	ConfirmationToken string `json:"confirmation_token"`
}

type UpsertChangeEmailRow struct {
	ConfirmationToken string `json:"confirmation_token"`
	NewEmail          string `json:"new_email"`
}

func (q *Queries) UpsertChangeEmail(ctx context.Context, arg UpsertChangeEmailParams) (UpsertChangeEmailRow, error) {
	row := q.db.QueryRow(ctx, upsertChangeEmail, arg.Uuid, arg.NewEmail, arg.ConfirmationToken)
	var i UpsertChangeEmailRow
	err := row.Scan(&i.ConfirmationToken, &i.NewEmail)
	return i, err
}

const validateChatID = `-- name: ValidateChatID :one
SELECT chat_id
FROM chats
WHERE chat_id = $1
`

func (q *Queries) ValidateChatID(ctx context.Context, chatID string) (string, error) {
	row := q.db.QueryRow(ctx, validateChatID, chatID)
	var chat_id string
	err := row.Scan(&chat_id)
	return chat_id, err
}
